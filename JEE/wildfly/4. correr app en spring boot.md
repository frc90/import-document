Est√°s construyendo un **Spring Boot 3.5.3** empaquetado como **`jar` ejecutable** (`<packaging>jar</packaging>`).

---

### üìå Contexto

* Spring Boot **ya trae su propio servidor embebido** (por defecto `Tomcat` o `Jetty`).
* Cuando empaquetas como `jar`, la idea es correr con:

```bash
java -jar modulocomunicaciones-backend-1.0.jar
```

---

### Opciones que ten√©s

#### üîπ Ejecutar como JAR standalone (m√°s simple üöÄ)

Tu flujo ser√≠a:

```bash
mvn clean package
java -jar target/modulocomunicaciones-backend-1.0.jar
```

---

#### üîπ Adaptar tu proyecto para WAR (si quer√©s s√≠ o s√≠ usar WildFly)

Si realmente lo quer√©s correr dentro de WildFly:

1. Cambi√° en el `pom.xml`

   ```xml
   <packaging>war</packaging>
   ```
2. Agreg√° una clase que extienda `SpringBootServletInitializer`:

   ```java
   @SpringBootApplication
   public class ModulocomunicacionesBackendApplication extends SpringBootServletInitializer {
       @Override
       protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) {
           return builder.sources(ModulocomunicacionesBackendApplication.class);
       }

       public static void main(String[] args) {
           SpringApplication.run(ModulocomunicacionesBackendApplication.class, args);
       }
   }
   ```
3. Exclu√≠ el Tomcat embebido (porque WildFly ya trae servidor):

   ```xml
   <dependency>
       <groupId>org.springframework.boot</groupId>
       <artifactId>spring-boot-starter-web</artifactId>
       <exclusions>
           <exclusion>
               <groupId>org.springframework.boot</groupId>
               <artifactId>spring-boot-starter-tomcat</artifactId>
           </exclusion>
       </exclusions>
   </dependency>
   ```
4. Empaquet√° con `mvn clean package` ‚Üí se genera un `.war` en `target/`.
5. Deploy ese `.war` en WildFly (`standalone/deployments`).

Con eso, ya no se pelea el logging ni el servidor embebido.

---